# -*- coding: utf-8 -*-
"""K214142072_NgoVoNgocMai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kwl1EqUlWdt0i2q3XRcSE9xoUuCUKa3i
"""

import pandas as pd
import pandas_ta as ta
import numpy as np
import datetime
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from xgboost import XGBClassifier
from catboost import CatBoostClassifier
from sklearn.experimental import enable_hist_gradient_boosting
from sklearn.ensemble import HistGradientBoostingClassifier
from lightgbm import LGBMClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.metrics import confusion_matrix

!pip install pandas_ta
!pip install -U vnstock
#pip install catboost
#pip install lightgbm
#pip install pdpbox
#pip install tensorflow

from vnstock import *

# Danh sách mã chỉ số
indices_listing(lang='vi')

# Lấy dữ liệu lịch sử của mã chỉ số
df = stock_historical_data("VNINDEX", "2004-06-03", "2024-06-03", "1D", "index", source='TCBS')
print(df)

"""### Tính toán thêm các biến
#### Dữ liệu bao gồm giá đóng cửa (Close), giá mở cửa (Open), chỉ số cao nhất (High), thấp nhất (Low) và khối lượng giao dịch (Volume)
#### RSI, MACD, STOCH,
#### ADX (Average directional index) là chỉ số định hướng trung bình, dùng để xác định độ mạnh hay yếu của chiều biến động trong 14 ngày
#### MFI
#### 52WH và 52WL là mức giá cao nhất và mức giá thấp nhất của chỉ số Vnindex trong một năm
"""

# Kiểm tra dữ liệu
print(df.dtypes)
print(df.isnull().any())

df1 = df.copy()  # Tạo một bản sao của DataFrame df
# Bảng in ra thống kê mô tả
df1_cleaned = df1[df1['volume'] != 0]
df1_cleaned
#df5 = df5.drop('label', axis=1)
#df6 = df2.drop('previous_close', axis=1)
#df7 = df6[df6['volume'] != 0]

# RSI
def calculate_rsi(df1_cleaned, window=14):
    delta = df1_cleaned['close'].diff()
    up = delta.where(delta < 0, 0).rolling(window).mean()
    down = -delta.where(delta > 0, 0).rolling(window).mean()

    rs = up / down
    rsi = 100 - (100 / (1 + rs))

    return rsi
df1_cleaned['rsi'] = calculate_rsi(df1_cleaned)
df1_cleaned
# STOCH
def calculate_stoch(df1_cleaned, n=14, m=3):
    # Tính %K
    lowest_low = df1_cleaned['low'].rolling(window=n).min()
    highest_high = df1_cleaned['high'].rolling(window=n).max()
    stoch = 100 * ((df1_cleaned['close'] - lowest_low) / (highest_high - lowest_low))

    return stoch
df1_cleaned['stoch'] = calculate_stoch(df1_cleaned)
df1_cleaned
# MACD
def calculate_macd(df1_cleaned, n=14, m=3):
    # Tính toán các giá trị MACD
    ema_12 = df1_cleaned['close'].ewm(span=12, adjust=False).mean()
    ema_26 = df1_cleaned['close'].ewm(span=26, adjust=False).mean()
    macd = ema_12 - ema_26
    return macd
df1_cleaned['macd'] = calculate_macd(df1_cleaned)
df1_cleaned
def calculate_adx(df1, n=14):
    # Calculate True Range (TR)
    high_low = df1_cleaned['high'] - df1_cleaned['low']
    high_close = np.abs(df1_cleaned['high'] - df1_cleaned['close'].shift(1))
    low_close = np.abs(df1_cleaned['low'] - df1_cleaned['close'].shift(1))
    TR = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)

    # Calculate directional movement
    plus_dm = df1_cleaned['high'].diff()
    minus_dm = df1_cleaned['low'].diff().abs()
    DMplus = np.where((plus_dm > minus_dm) & (plus_dm > 0), plus_dm, 0)
    DMminus = np.where((minus_dm > plus_dm) & (minus_dm > 0), minus_dm, 0)

    # Convert to pandas Series
    TR = pd.Series(TR, index=df1.index)
    DMplus = pd.Series(DMplus, index=df1.index)
    DMminus = pd.Series(DMminus, index=df1.index)

    # Calculate the smoothed averages
    ATR = TR.rolling(window=n, min_periods=1).mean()
    DIplus = 100 * (DMplus.rolling(window=n, min_periods=1).sum() / ATR)
    DIminus = 100 * (DMminus.rolling(window=n, min_periods=1).sum() / ATR)

    # Calculate the DX
    DX = (abs(DIplus - DIminus) / (DIplus + DIminus)) * 100

    # Calculate the ADX
    ADX = DX.rolling(window=n, min_periods=1).mean()

    return ADX

df1_cleaned['adx'] = calculate_adx(df1_cleaned)

def calculate_mfi(df1, n=14):
    # Calculate the Typical Price (TP)
    TP = (df1_cleaned['high'] + df1_cleaned['low'] + df1_cleaned['close']) / 3

    # Calculate the Money Flow (MF)
    MF = TP * df1_cleaned['volume']

    # Calculate Positive and Negative Money Flow
    TP_diff = TP.diff()
    MFplus = np.where(TP_diff > 0, MF, 0)
    MFminus = np.where(TP_diff < 0, MF, 0)

    # Convert MFplus and MFminus to DataFrame to use rolling
    MFplus = pd.Series(MFplus, index=df1.index)
    MFminus = pd.Series(MFminus, index=df1.index)

    # Calculate the rolling sums of Positive and Negative Money Flow
    MFplus14 = MFplus.rolling(window=n, min_periods=1).sum()
    MFminus14 = MFminus.rolling(window=n, min_periods=1).sum()

    # Calculate the Money Flow Ratio (MFR)
    MFR = MFplus14 / MFminus14

    # Calculate the Money Flow Index (MFI)
    MFI = 100 - (100 / (1 + MFR))

    return MFI

df1_cleaned['mfi'] = calculate_mfi(df1_cleaned)

df1_cleaned

df2 = df1_cleaned.drop('ticker', axis=1)
df2['time'] = pd.to_datetime(df2['time'])
df2.set_index('time', inplace=True)

def calculate_52W(df2):
    # Tính toán 52WH và 52WL
    WH52 = df2['close'].rolling(window=246, min_periods=1).max()  # 52 tuần ~ 246 ngày giao dịch
    WL52 = df2['close'].rolling(window=246, min_periods=1).min()

    return WH52, WL52

df2['WH52'], df2['WL52'] = calculate_52W(df2)
df2

# Phân loại chiều hướng biến động giá cp
def calculate_label(df2):
    # Shift the 'close' column by -1 to get the close price of the next day
    df2['previous_close'] = df2['close'].shift(1)

    # Initialize the 'label' column with 0
    df2['label'] = 0

    # Set 'label' to 1 where the next day's close is higher than today's close
    df2.loc[df2['previous_close'] < df2['close'], 'label'] = 1

    return df2

# Apply the function to add the 'label' column
df2 = calculate_label(df2)
df2 = calculate_label(df2)
df2

# Bảng chuẩn để chạy mô hình
df3 = df2.drop('previous_close', axis=1)
df3

# Bảng in ra thống kê mô tả
df3_description = df3.drop('label', axis=1)
df3_description

df4 = df3.copy()
# Sử dụng apply với lambda để thay thế giá trị trong cột stoch
df4['stoch'] = df4['stoch'].apply(lambda x: 0 if x < 0 else (100 if x > 100 else x))
df4

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import accuracy_score, classification_report
from sklearn.ensemble import HistGradientBoostingClassifier
from xgboost import XGBClassifier
from catboost import CatBoostClassifier
from lightgbm import LGBMClassifier

# Chuẩn bị dữ liệu
X = df4.drop(columns=['label'])
y = df4['label']

# Chia dữ liệu thành tập huấn luyện và tập kiểm tra
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)

# Định nghĩa các mô hình
models = {
    "HistGradientBoosting": HistGradientBoostingClassifier(),
    "CatBoost": CatBoostClassifier(verbose=0),
    "LightGBM": LGBMClassifier(verbosity=-1)
}

# Huấn luyện và đánh giá các mô hình
results = {}
for model_name, model in models.items():
    model.fit(X_train, y_train)
    predictions = model.predict(X_test)
    accuracy = accuracy_score(y_test, predictions)
    report = classification_report(y_test, predictions, output_dict=True)
    results[model_name] = {"accuracy": accuracy, "classification_report": report}

# Tạo và tinh chỉnh mô hình XGBoost
xgb_model = XGBClassifier(use_label_encoder=False, eval_metric='logloss')

# Danh sách các siêu tham số cần tinh chỉnh và các giá trị ứng viên
param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [3, 4, 5],
    'learning_rate': [0.1, 0.01, 0.05],
    'min_child_weight': [1, 2, 3]
}

# Sử dụng Grid Search để tìm kiếm siêu tham số tốt nhất
grid_search = GridSearchCV(estimator=xgb_model, param_grid=param_grid, scoring='accuracy', cv=5)
grid_search.fit(X_train, y_train)

# Lưu kết quả của XGBoost đã tinh chỉnh
xgb_tuned = grid_search.best_estimator_
xgb_predictions = xgb_tuned.predict(X_test)
xgb_accuracy = accuracy_score(y_test, xgb_predictions)
xgb_report = classification_report(y_test, xgb_predictions, output_dict=True)

results["XGBoost"] = {"accuracy": xgb_accuracy, "classification_report": xgb_report}

# Hiển thị kết quả
for model_name, metrics in results.items():
    print(f"Model: {model_name}")
    print(f"Accuracy: {metrics['accuracy']}")
    print("Classification Report:")
    print(pd.DataFrame(metrics['classification_report']).transpose())
    print("\n")

# So sánh accuracy
accuracy_scores = {model_name: metrics['accuracy'] for model_name, metrics in results.items()}
accuracy_df = pd.DataFrame(list(accuracy_scores.items()), columns=["Model", "Accuracy"])
plt.figure(figsize=(10, 8))
sns.barplot(x="Accuracy", y="Model", data=accuracy_df)
plt.title("Model Accuracy Comparison")
plt.show()

from lightgbm import LGBMClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# Chuẩn bị dữ liệu
X = df4.drop(columns=['label'])
y = df4['label']

# Chia dữ liệu thành tập huấn luyện và tập kiểm tra
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)

# Tạo và huấn luyện mô hình LightGBM
lgbm_model = LGBMClassifier(verbosity=-1)
lgbm_model.fit(X_train, y_train)

# Dự đoán trên tập kiểm tra
lgbm_preds = lgbm_model.predict(X_test)

# Đánh giá mô hình
print("LightGBM Classification Report:")
print(classification_report(y_test, lgbm_preds))
print("Accuracy: ", accuracy_score(y_test, lgbm_preds))

# In ma trận nhầm lẫn
cm = confusion_matrix(y_test, lgbm_preds)
print("Confusion Matrix:")
print(cm)

# Vẽ heatmap của ma trận nhầm lẫn
plt.figure(figsize=(10, 7))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix for LightGBM Model")
plt.show()

from lightgbm import plot_importance

# Vẽ biểu đồ các biến quan trọng
plt.figure(figsize=(10, 8))
plot_importance(lgbm_model, max_num_features=12)
plt.title('Important Features')
plt.show()

df5 = df4.drop('label', axis=1)

description = df5.describe()
description = description.applymap(lambda x: '{:.6f}'.format(x).rstrip('0').rstrip('.'))

description
description.to_excel('description.xlsx')

df_chart = df.copy()
fig = go.Figure()
#Đường giá
fig.add_trace(go.Scatter( x=df_chart['time'], y=df_chart['close'], mode='lines', name='Price', line=dict(color='blue', width=1) ))
fig.update_layout( title="VNindex price chart", xaxis_title='Time', yaxis_title='Close Price', showlegend=True, plot_bgcolor='white' )

df4.to_excel('machinelearningsemester.xlsx')